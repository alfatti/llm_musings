Option Explicit

' ==========================
' Configuration
' ==========================
Private Const GEMINI_ENDPOINT As String = "https://your-enterprise-gateway.example.com/v1/models/gemini-2.5-flash:generateContent"
Private Const MODEL_NAME As String = "gemini-2.5-flash"
Private Const ROWS_PER_CHUNK As Long = 150
Private Const OUTPUT_SHEET_NAME As String = "output"
Private Const EXTRACT_SHEET_NAME As String = "RENT_ROLL_EXTRACTED_WO_CONCESSIONS"
Private Const SECRETS_SHEET As String = "__secrets"
Private Const SECRETS_TOKEN_CELL As String = "A1"

' ==========================
' Entry Point
' ==========================
Public Sub ExtractRentRollPipeline()
    On Error GoTo EH

    Dim wsRR As Worksheet
    Set wsRR = RequireSheet("RAW_RENT_ROLL")

    Dim wsExtract As Worksheet, wsOut As Worksheet, wsC As Worksheet
    Dim concessionsAvailable As Boolean
    concessionsAvailable = False
    If SheetExists("CONCESSIONS") Then
        Set wsC = ThisWorkbook.Worksheets("CONCESSIONS")
        concessionsAvailable = Not IsSheetEffectivelyEmpty(wsC)
    End If

    ' (Re)create extract and (maybe) output sheets
    KillSheetIfExists EXTRACT_SHEET_NAME
    Set wsExtract = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
    wsExtract.Name = EXTRACT_SHEET_NAME

    KillSheetIfExists OUTPUT_SHEET_NAME
    If concessionsAvailable Then
        Set wsOut = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))
        wsOut.Name = OUTPUT_SHEET_NAME
    End If

    ' 1) Detect header in RAW_RENT_ROLL and read as TSV
    Dim headerRow As Long
    headerRow = DetectHeaderRow(wsRR, Array("Unit", "Rent", "Status"))
    If headerRow = 0 Then headerRow = 1

    Dim rrTSV As String
    rrTSV = RangeToTSV(wsRR, headerRow)

    ' 2) Chunk → call Gemini → aggregate CSV
    Dim chunks As Collection: Set chunks = ChunkTSV(rrTSV, ROWS_PER_CHUNK)
    Dim allCsv As String, i As Long
    For i = 1 To chunks.Count
        Dim csvChunk As String
        csvChunk = CallGeminiExtract(chunks(i))
        If Len(allCsv) = 0 Then
            allCsv = csvChunk
        Else
            allCsv = AppendCsv(allCsv, csvChunk)
        End If
        DoEvents
    Next i

    ' 3) Write extracted CSV to the EXTRACT sheet
    WriteCSVToSheet allCsv, wsExtract, 1, 1

    ' 4) If no concessions, stop here with a popup
    If Not concessionsAvailable Then
        MsgBox "CONCESSIONS tab is missing or empty. Wrote intermediate results to '" & EXTRACT_SHEET_NAME & "'.", vbInformation
        Exit Sub
    End If

    ' 5) LEFT JOIN concessions onto extract → output
    Dim unitCol As Long, rentCol As Long, statusCol As Long
    unitCol = FindHeaderColumn(wsExtract, "Unit")
    rentCol = FindHeaderColumn(wsExtract, "Rent")
    statusCol = FindHeaderColumn(wsExtract, "Status")

    If unitCol = 0 Then Err.Raise vbObjectError + 201, , "Intermediate extract is missing 'Unit' column."

    Dim concMap As Object: Set concMap = CreateObject("Scripting.Dictionary")
    LoadConcessionsMap wsC, concMap

    ' Copy extract table to output first
    wsOut.Cells.Clear
    Dim lastRow As Long, lastCol As Long
    lastRow = wsExtract.Cells(wsExtract.Rows.Count, 1).End(xlUp).Row
    lastCol = wsExtract.Cells(1, wsExtract.Columns.Count).End(xlToLeft).Column
    wsExtract.Range(wsExtract.Cells(1, 1), wsExtract.Cells(lastRow, lastCol)).Copy Destination:=wsOut.Cells(1, 1)

    ' Add is_concession + concession_amount
    Dim addCol1 As Long, addCol2 As Long
    addCol1 = lastCol + 1
    addCol2 = lastCol + 2
    wsOut.Cells(1, addCol1).Value = "is_concession"
    wsOut.Cells(1, addCol2).Value = "concession_amount"

    Dim r As Long, u As String, amt As Double
    For r = 2 To lastRow
        u = CStr(wsOut.Cells(r, unitCol).Value)
        If concMap.Exists(u) Then
            wsOut.Cells(r, addCol1).Value = True
            amt = CDbl(concMap(u))
            wsOut.Cells(r, addCol2).Value = amt
        Else
            wsOut.Cells(r, addCol1).Value = False
            wsOut.Cells(r, addCol2).Value = 0
        End If
    Next r

    ' Sanity checks (optional but handy)
    rentCol = FindHeaderColumn(wsOut, "Rent")
    statusCol = FindHeaderColumn(wsOut, "Status")
    Dim totalRent As Double, nOcc As Long, nVac As Long
    totalRent = SumColumn(wsOut, rentCol)
    nOcc = CountByValue(wsOut, statusCol, "Occupied")
    nVac = CountByValue(wsOut, statusCol, "Vacant")

    Dim tailRow As Long: tailRow = wsOut.Cells(wsOut.Rows.Count, 1).End(xlUp).Row + 2
    wsOut.Cells(tailRow, 1).Value = "Sanity Check Summary"
    wsOut.Cells(tailRow + 1, 1).Value = "Total Rent": wsOut.Cells(tailRow + 1, 2).Value = totalRent
    wsOut.Cells(tailRow + 2, 1).Value = "# Occupied": wsOut.Cells(tailRow + 2, 2).Value = nOcc
    wsOut.Cells(tailRow + 3, 1).Value = "# Vacant": wsOut.Cells(tailRow + 3, 2).Value = nVac

    MsgBox "Pipeline complete." & vbCrLf & _
           "Intermediate: '" & EXTRACT_SHEET_NAME & "'" & vbCrLf & _
           "Final joined output: '" & OUTPUT_SHEET_NAME & "'", vbInformation
    Exit Sub

EH:
    MsgBox "Error: " & Err.Description, vbCritical
End Sub

' ==========================
' Sheet helpers
' ==========================
Private Function RequireSheet(name As String) As Worksheet
    If Not SheetExists(name) Then Err.Raise vbObjectError + 301, , "Required sheet '" & name & "' not found."
    Set RequireSheet = ThisWorkbook.Worksheets(name)
End Function

Private Function SheetExists(name As String) As Boolean
    On Error Resume Next
    SheetExists = Not ThisWorkbook.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Sub KillSheetIfExists(name As String)
    On Error Resume Next
    Application.DisplayAlerts = False
    ThisWorkbook.Worksheets(name).Delete
    Application.DisplayAlerts = True
    On Error GoTo 0
End Sub

Private Function IsSheetEffectivelyEmpty(ws As Worksheet) As Boolean
    If WorksheetFunction.CountA(ws.UsedRange) = 0 Then
        IsSheetEffectivelyEmpty = True
        Exit Function
    End If
    ' If only header row or no data under first column
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    IsSheetEffectivelyEmpty = (lastRow < 2)
End Function

' ==========================
' Rent Roll → TSV helpers
' ==========================
Private Function DetectHeaderRow(ws As Worksheet, mustHaveHeaders As Variant) As Long
    Dim lastRow As Long, lastCol As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column

    Dim r As Long, c As Long, hits As Long, needed As Long
    needed = UBound(mustHaveHeaders) - LBound(mustHaveHeaders) + 1
    For r = 1 To WorksheetFunction.Min(20, lastRow)
        hits = 0
        For c = 1 To lastCol
            Dim cellVal As String
            cellVal = Trim(CStr(ws.Cells(r, c).Value))
            If Len(cellVal) > 0 Then
                Dim k As Long
                For k = LBound(mustHaveHeaders) To UBound(mustHaveHeaders)
                    If StrComp(cellVal, CStr(mustHaveHeaders(k)), vbTextCompare) = 0 Then
                        hits = hits + 1
                        Exit For
                    End If
                Next k
            End If
        Next c
        If hits >= WorksheetFunction.Max(1, needed - 1) Then
            DetectHeaderRow = r
            Exit Function
        End If
    Next r
    DetectHeaderRow = 0
End Function

Private Function RangeToTSV(ws As Worksheet, headerRow As Long) As String
    Dim lastRow As Long, lastCol As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    lastCol = ws.Cells(headerRow, ws.Columns.Count).End(xlToLeft).Column

    Dim r As Long, c As Long, sb As String
    For r = headerRow To lastRow
        Dim line As String: line = ""
        For c = 1 To lastCol
            Dim v As String
            v = CStr(ws.Cells(r, c).Value)
            v = Replace(v, vbTab, " ")
            v = Replace(v, vbCr, " ")
            v = Replace(v, vbLf, " ")
            If c = 1 Then line = v Else line = line & vbTab & v
        Next c
        sb = sb & line & vbCrLf
    Next r
    RangeToTSV = sb
End Function

Private Function ChunkTSV(tsv As String, rowsPerChunk As Long) As Collection
    Dim lines() As String
    lines = Split(tsv, vbCrLf)
    If UBound(lines) < 0 Then
        Dim emptyCol As New Collection
        Set ChunkTSV = emptyCol
        Exit Function
    End If

    Dim header As String: header = lines(0)
    Dim i As Long, startIdx As Long, cnt As Long
    Dim col As New Collection

    startIdx = 1
    Do While startIdx < UBound(lines) + 1
        cnt = WorksheetFunction.Min(rowsPerChunk, UBound(lines) - startIdx + 1)
        If cnt <= 0 Then Exit Do

        Dim chunk As String
        chunk = header & vbCrLf & Join(Slice(lines, startIdx, cnt), vbCrLf)
        col.Add chunk
        startIdx = startIdx + cnt
    Loop

    Set ChunkTSV = col
End Function

Private Function Slice(arr() As String, startIdx As Long, count As Long) As String()
    Dim out() As String
    ReDim out(0 To count - 1)
    Dim i As Long
    For i = 0 To count - 1
        out(i) = arr(startIdx + i)
    Next i
    Slice = out
End Function

' ==========================
' Gemini Call (2.5-Flash)
' ==========================
Private Function CallGeminiExtract(tsvChunk As String) As String
    Dim prompt As String
    prompt = BuildPrompt()

    Dim bearer As String
    bearer = GetBearerToken()

    Dim body As String
    body = BuildGeminiBody(prompt, tsvChunk)

    Dim resp As String
    resp = HttpPostJson(GEMINI_ENDPOINT, bearer, body)

    Dim csvOut As String
    csvOut = ExtractTextFromGeminiResponse(resp)
    csvOut = ExtractCSVBlock(csvOut)

    CallGeminiExtract = csvOut
End Function

Private Function BuildPrompt() As String
    Dim p As String
    p = p & "You are extracting structured rows from a rent roll table." & vbLf
    p = p & "INPUT FORMAT: tab-separated values (TSV) with a header row and data rows." & vbLf
    p = p & "TASK: For each input row (one unit), produce one output row with the following columns EXACTLY in this order:" & vbLf
    p = p & "Unit|Status|Rent" & vbLf
    p = p & "— Unit: the unit identifier as shown (string)." & vbLf
    p = p & "— Status: 'Occupied' or 'Vacant'. If unclear, infer from context words (e.g., 'Current Resident' implies Occupied)." & vbLf
    p = p & "— Rent: scheduled/base monthly rent as a number (no currency symbols). Use 0 if truly missing." & vbLf
    p = p & "OUTPUT FORMAT: Return ONLY a single pipe-delimited CSV block with header in the first row, like:" & vbLf
    p = p & "Unit|Status|Rent" & vbLf & "101|Occupied|2350" & vbLf & "..." & vbLf
    p = p & "STRICT RULES:" & vbLf
    p = p & "1) Use '|' as the delimiter." & vbLf
    p = p & "2) No explanations outside the CSV." & vbLf
    p = p & "3) If a row is a section header or subtotal, skip it." & vbLf
    p = p & "4) Convert any currency strings to bare numbers."
    BuildPrompt = p
End Function

Private Function BuildGeminiBody(prompt As String, tsv As String) As String
    Dim payload As String
    payload = "{""contents"":[{""role"":""user"",""parts"":[{""text"":""" & _
              EscapeJson(prompt) & "\n\nTSV INPUT:\n" & EscapeJson(tsv) & """}]}]," & _
              """generationConfig"":{""temperature"":0,""topP"":0.95,""topK"":40}}"
    BuildGeminiBody = payload
End Function

Private Function GetBearerToken() As String
    If Not SheetExists(SECRETS_SHEET) Then _
        Err.Raise vbObjectError + 401, , "Secrets sheet '" & SECRETS_SHEET & "' not found."
    Dim tok As String
    tok = Trim$(CStr(ThisWorkbook.Worksheets(SECRETS_SHEET).Range(SECRETS_TOKEN_CELL).Value))
    If Len(tok) = 0 Then Err.Raise vbObjectError + 402, , "'" & SECRETS_SHEET & "!" & SECRETS_TOKEN_CELL & "' is empty. Paste GEMINI_BEARER there."
    GetBearerToken = tok
End Function

Private Function HttpPostJson(url As String, bearer As String, body As String) As String
    Dim http As Object
    Set http = CreateObject("WinHttp.WinHttpRequest.5.1")

    http.Open "POST", url, False
    http.SetRequestHeader "Content-Type", "application/json"
    If Len(bearer) > 0 Then http.SetRequestHeader "Authorization", "Bearer " & bearer
    http.Send body

    Dim status As Long
    status = http.Status
    If status < 200 Or status >= 300 Then
        Err.Raise vbObjectError + 403, , "HTTP error " & status & ": " & http.ResponseText
    End If

    HttpPostJson = http.ResponseText
End Function

Private Function ExtractTextFromGeminiResponse(resp As String) As String
    ' Greedy extraction of all "text":"..." parts (Vertex-style response)
    Dim out As String, pos As Long, startPos As Long, endPos As Long
    pos = 1
    Do
        pos = InStr(pos, resp, """text"":""")
        If pos = 0 Then Exit Do
        startPos = pos + Len("""text"":""")
        endPos = startPos
        Do While endPos <= Len(resp)
            If Mid$(resp, endPos, 2) = "\"" Then
                endPos = endPos + 2
            ElseIf Mid$(resp, endPos, 1) = """" Then
                Exit Do
            Else
                endPos = endPos + 1
            End If
        Loop
        Dim piece As String
        piece = Mid$(resp, startPos, endPos - startPos)
        piece = Replace(piece, "\n", vbCrLf)
        piece = Replace(piece, "\\", "\")
        piece = Replace(piece, "\"" , """")
        out = out & piece & vbCrLf
        pos = endPos + 1
    Loop
    ExtractTextFromGeminiResponse = Trim$(out)
End Function

Private Function ExtractCSVBlock(modelText As String) As String
    Dim lines() As String
    lines = Split(modelText, vbCrLf)
    Dim i As Long, keeper As String
    For i = LBound(lines) To UBound(lines)
        If InStr(lines(i), "|") > 0 Then keeper = keeper & lines(i) & vbCrLf
    Next i
    ExtractCSVBlock = Trim$(keeper)
End Function

Private Function AppendCsv(existingCsv As String, newCsv As String) As String
    Dim newLines() As String
    newLines = Split(newCsv, vbCrLf)
    Dim i As Long, sb As String
    sb = existingCsv
    For i = 1 To UBound(newLines) ' skip header
        If Len(Trim$(newLines(i))) > 0 Then sb = sb & vbCrLf & newLines(i)
    Next i
    AppendCsv = sb
End Function

' ==========================
' CSV → Sheet helpers
' ==========================
Private Sub WriteCSVToSheet(csvText As String, ws As Worksheet, startRow As Long, startCol As Long)
    Dim lines() As String, parts() As String
    lines = Split(csvText, vbCrLf)
    Dim r As Long, c As Long
    For r = 0 To UBound(lines)
        parts = Split(lines(r), "|")
        For c = 0 To UBound(parts)
            ws.Cells(startRow + r, startCol + c).Value = parts(c)
        Next c
    Next r
End Sub

Private Function FindHeaderColumn(ws As Worksheet, headerName As String) As Long
    Dim lastCol As Long, c As Long
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    For c = 1 To lastCol
        If StrComp(Trim$(CStr(ws.Cells(1, c).Value)), headerName, vbTextCompare) = 0 Then
            FindHeaderColumn = c
            Exit Function
        End If
    Next c
    FindHeaderColumn = 0
End Function

' ==========================
' Concessions → Map and Join
' ==========================
Private Sub LoadConcessionsMap(ws As Worksheet, ByRef m As Object)
    Dim unitCol As Long, amtCol As Long
    unitCol = LocateHeader(ws, Array("Unit"))
    amtCol = LocateHeader(ws, Array("concession_amount", "Amount", "Concession", "Concession Amount"))
    If unitCol = 0 Or amtCol = 0 Then
        Err.Raise vbObjectError + 501, , "CONCESSIONS sheet missing 'Unit' and/or 'Amount' column."
    End If

    Dim lastRow As Long, r As Long
    lastRow = ws.Cells(ws.Rows.Count, unitCol).End(xlUp).Row

    For r = 2 To lastRow
        Dim u As String, a As Variant
        u = CStr(ws.Cells(r, unitCol).Value)
        a = ws.Cells(r, amtCol).Value
        If Len(u) > 0 Then
            If Not m.Exists(u) Then m.Add u, CDbl(Val(a)) Else m(u) = CDbl(Val(a))
        End If
    Next r
End Sub

Private Function LocateHeader(ws As Worksheet, names As Variant) As Long
    Dim lastCol As Long, c As Long, k As Long
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    For c = 1 To lastCol
        Dim v As String: v = Trim$(CStr(ws.Cells(1, c).Value))
        For k = LBound(names) To UBound(names)
            If StrComp(v, CStr(names(k)), vbTextCompare) = 0 Then
                LocateHeader = c
                Exit Function
            End If
        Next k
    Next c
    LocateHeader = 0
End Function

' ==========================
' Totals & Counts
' ==========================
Private Function SumColumn(ws As Worksheet, colIdx As Long) As Double
    If colIdx = 0 Then Exit Function
    Dim lastRow As Long, r As Long, s As Double
    lastRow = ws.Cells(ws.Rows.Count, colIdx).End(xlUp).Row
    For r = 2 To lastRow
        s = s + CDbl(Val(ws.Cells(r, colIdx).Value))
    Next r
    SumColumn = s
End Function

Private Function CountByValue(ws As Worksheet, colIdx As Long, valueToMatch As String) As Long
    If colIdx = 0 Then Exit Function
    Dim lastRow As Long, r As Long, n As Long
    lastRow = ws.Cells(ws.Rows.Count, colIdx).End(xlUp).Row
    For r = 2 To lastRow
        If StrComp(Trim$(CStr(ws.Cells(r, colIdx).Value)), valueToMatch, vbTextCompare) = 0 Then
            n = n + 1
        End If
    Next r
    CountByValue = n
End Function

' ==========================
' Utilities
' ==========================
Private Function EscapeJson(s As String) As String
    Dim t As String
    t = Replace(s, "\", "\\")
    t = Replace(t, """", "\""")
    t = Replace(t, vbCrLf, "\n")
    t = Replace(t, vbCr, "\n")
    t = Replace(t, vbLf, "\n")
    EscapeJson = t
End Function
